<!DOCTYPE html>

<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>Вопросы QA</title>
	<h1><p align="center">Опыт</p></h1>
	</head>
	<p>  
1.Опишите проект(ы), в которых приходилось работать <br />
2.Как вы представляете себе работу тестировщика?<br />
3.Почему хотите работать именно в тестировании?<br />
4.Почему хотите поменять работу?<br />
5.Какие книги/журналы о тестировании читали?<br />
	</p>
<h1><p align="center">Теория/методологии</p></h1>
	<p>
1.Цели тестирования <br /><br />
		– Предоставление информации о качестве ПО конечному заказчику;<br />
		– Повышение качества ПО;<br />
		– Предотвращение появления дефектов.<br />
		Цели тестирования могут отличаться, в зависимости от этапа разработки ПО, на котором оно проводится. К примеру, на этапе кодирования
		целью тестирования будет вызов как можно большего количества сбоев в работе программы, что позволит локализовать и исправить дефекты.
		В то же время, при приемочном тестировании необходимо  показать, что система работает правильно. В период сопровождения, тестирование в основном
		необходимо для того, чтобы  убедится в отсутствии новых багов, появившихся во время внесения изменений.
		Главная же задача тестирования – поиск дефектов.<br /><br />
2.Как оценить качество тестирования? <br /><br />
		Группа 1 — Требования к разрабатываемому ПО <br /><br />
		1. Тестовое покрытие требования<br />
		«Общее количество тестов» / «Общее количество требований»<br />
		Назначение метрики: выявить слабые места в тестовом покрытии, подсветить риски.<br />
		-Данная метрика будет работать, только если требования хорошо декомпозированы на равнозначные. Иначе она превратится в индикатор наличия или<br />
		отсутствия тестов для каждого из требований.<br />
		-Для требований, у которых коэффициент будет равен или близок к 0, нужно рассмотреть возможность добавления тестов.<br /><br />

		2. Степень взаимосвязанности требований<br />
		AVERAGE («Количество требований, связанных с требованием №1» / «Общее количество требований -1» ,…, «Количество требований, связанных с требованием №n»<br />
		/ «Общее количество требований -1»)<br />
		Метрика вычисляется как количество связей каждого требования с остальными требованиями. При этом используется среднее по всем требованиям значение.<br />
		Назначение метрики: дать основание для оценки сроков тестирования и учета возможных рисков. Зная степень взаимного влияния требований друг на друга,<br />
		можно, например, запланировать дополнительное время и кейсы для сквозного тестирования, проработать регрессионные проверки, посмотреть в сторону<br />
		интеграции и т.п.<br /><br />

		3. Коэффициент стабильности требований<br />
		«Количество изменений в существующих требованиях» / «Общее количество требований, реализованных за итерацию, включая новые»<br />
		Назначение метрики: показать, как много уже реализованных требований приходится переделывать от релиза к релизу при разработке новых фич.<br />
		Также метрика дает представление о том, насколько легко масштабируется функционал системы, добавляются новые возможности.<br />
		Для данной метрики коэффициент должен быть как минимум меньше 0,5. В этом случае мы внедряем новых фич в 2 раза больше, чем переделываем существующих.<br />
		В противном случае команда больше фокусируется на переделывании ранее выпущенных фич, а не на создании новых ценностей для бизнеса.<br /><br />

		Группа 2 — Качество разрабатываемого продукта<br />
		Данная группа метрик позволяет оценить и сравнить от релиза к релизу как качество ПО, так и качество самой разработки.<br /><br />

		1. Плотность дефектов<br />
		«Количество дефектов в отдельном модуле» / «Общее количество дефектов в ПО»<br />
		Рассчитывается как доля дефектов от общего их числа, приходящихся на отдельный модуль в рамках итерации или релиза.<br />
		Назначение метрики: подсветить, какая часть ПО является наиболее проблемной. Эта информация поможет при оценке и планировании работ с данным модулем,а также при анализе рисков.<br /><br />

		Данная метрика поможет обратить наше внимание на проблемный модуль\систему\функциональность, где доля дефектов выше среднего.<br />
		2. Коэффициент регрессии<br />
		«Количество дефектов в старом функционале» / «Общее количество дефектов, включая новый функционал»<br />
		Назначение метрики: показать, на что уходят усилия команды — занимается ли она больше разработкой и отладкой новых фич или основную часть времени тратит на исправления в уже существующих частях ПО.<br />
		Например, если коэффициент регрессии больше 0,5, это значит, что больше половины времени мы тратим на восстановление ранее работавших функций ПО. Такую ситуацию требуется исправлять.<br /><br />

		3. Коэффициент повторно открытых дефектов<br />
		«Количество повторно обнаруженных дефектов» / «Общее количество ошибок, включая ранее исправленные и новые»<br />
		Назначение метрики: дать оценку качеству разработки и исправления дефектов, а также сложности продукта или отдельного модуля.<br />
		Чем ближе значение коэффициента к 0, тем меньше повторяются старые ошибки.<br />
		При этом, если значение больше 0,2-0,3, это может говорить либо о технической сложности модуля, либо о проблемах в архитектуре, либо о некачественном исправлении ошибок.<br /><br />

		Группа 3 – Возможности и эффективность команды QA<br />
		Основная задача данной группы метрик заключается в том, чтобы выразить в цифрах, на что способна команда тестирования. Эти показатели можно и нужно рассчитывать и сравнивать на регулярной основе, анализировать тенденции, наблюдая, как на работу команды влияют те или иные изменения.<br /><br />

		1. Скорость работы (velocity) команды QA<br />
		«Количество story points за N итераций)» / «N»<br />
		Рассчитывается как отношение реализованных story points \ требований \ user stories за несколько итераций \ sprints к количеству выбранных итераций.<br />
		Назначение метрики: численно выразить возможности, скорость работы команды для дальнейшего планирования объема работ и анализа трендов развития. Метрика позволяет следить за скоростью работы QA, наблюдать за тем, какие внутренние или внешние воздействия на команду влияют на эту скорость.<br />

		2. Среднее время жизни дефекта<br />
		«Суммарное время исправления найденных дефектов» / «Количество дефектов»<br />
		Общее время, в течение которого были открытыми дефекты, найденные в рамках итерации или релиза, к сумме дефектов.<br />
		Назначение метрики: показать, сколько в среднем времени уходит на работу с одним дефектом: на его регистрацию, исправление и воспроизведение. Данный показатель позволит оценить время, необходимое на тестирование, выделить области ПО, с которыми возникают наибольшие сложности.<br />
		Время жизни дефекта — это все время от его регистрации до закрытия за вычетом всех возможных приостановок работы. Показывая дефекты с наибольшим временем исправления, метрика позволит выявить особенно сложные и проблемные модули или «слабое звено» в команде разработки.<br /><br />

		Группа 4 — Качество работы команды тестирования<br />
		Задача этого набора метрик: оценить, насколько качественно тестировщики выполняют свои задачи, определить уровень компетенций и зрелости команды QA. Обладая таким набором показателей, можно сравнивать команду с ней же на разных отрезках времени или с другими, внешними группами тестирования.<br /><br />

		1. Эффективность тестов и тестовых наборов<br />
		«Количество обнаруженных ошибок» / «Количество кейсов в тестовом наборе»<br />
		Назначение метрики: показать, как много ошибок в среднем позволяют обнаружить наши кейсы. Эта метрика отражает качество тест дизайна и помогает следить за тенденцией его изменения.<br />
		Показатель «убойности» тестов позволяет мониторить эффективность каждого из тестовых наборов, как она меняется с течением времени. Это даст возможность вовремя дополнять их «свежими» тестами.<br />

		2. Коэффициент ошибок, пропущенных на продуктив<br />
		«Количество ошибок, обнаруженных после выпуска релиза» / «Общее количество ошибок, обнаруженных до и после релиза»<br />
		Назначение метрики: продемонстрировать качество тестирования и эффективность обнаружения ошибок — какая доля дефектов была отфильтрована, а какая прошла на продуктив.<br />
		Конечно, допустимый процент пропущенных ошибок будет зависеть от многих факторов, однако, если он >0,1, то тут явно есть проблема, ведь в таком случае каждый десятый дефект попал на продуктив и привел к сбоям ПО у пользователей.<br />

		3. Реальное время работы команды QA<br />
		«Время, потраченное на целевые QA активности» / «Общее количество рабочих часов команды»<br />
		Отношение времени, потраченного командой непосредственно на целевые QA активности, к общему количеству часов.<br />
		Назначение метрики: во-первых, увеличить точность планирования, а во-вторых, отслеживать и управлять эффективностью работы команды.<br />
		К целевым активностям могут относиться: анализ, дизайн, оценки, тестирование, рабочие встречи и многое другое, к нецелевым — простой из-за блокеров, проблемы в коммуникациях, недоступность ресурсов и т.п.<br />
		Конечно, данная метрика никогда не будет равна 1. Практика показывает, что для эффективных команд ее значение может составлять 0,5-0,6.<br />

		4. Точность оценки времени по областям\видам\типам работ<br />
		«Оценочное время работы» / «Фактическое время работы»<br />
		Назначение метрики: позволяет использовать поправочный коэффициент для последующих оценок.<br />
		Степень точности оценки можно определить для всей команды или отдельных тестировщиков, для всей системы или отдельных модулей ПО.<br /><br />

		Группа 5 — Обратная связь и удовлетворенность пользователей<br />
		И в заключение, группа метрик, показывающая, как продукт был принят конечными пользователями, насколько он соответствовал их ожиданиям. При этом в рамках оценки взаимодействия с пользователями нам важна не только обратная связь о самом ПО. Еще одна значимая задача этой группы метрик — показать, удовлетворены ли пользователи процессом взаимодействия с командой ИТ в целом и QA в частности.<br /><br />

		1. Удовлетворенность пользователей ИТ сервисом<br />
		Проводится регулярный опрос удовлетворенности пользователей сервисом ИТ с выставлением баллов.<br />
		Назначение метрики: показать, доверяют ли пользователи команде ИТ, понимают ли, как и почему организована ее работа, насколько эта работа оправдывает ожидания.<br />
		Метрика может служить индикатором того, что необходимо сфокусироваться на оптимизации процесса или сделать его понятнее и прозрачнее для пользователей.<br />
		Расчет показателя удовлетворенности можно проводить на основе результатов опроса по итогам поставки ПО. Для этого необходимо собрать все оценки и посчитать средний балл.<br />

		2. Удовлетворенность пользователей продуктом<br />
		Регулярный опрос пользователей о том, насколько они удовлетворены качеством продукта.<br />
		Назначение метрики: определить, насколько разрабатываемый продукт соответствует ожиданиям пользователей, в том ли направлении мы движемся, правильно ли определяем важность фич и выбираем варианты решений.<br />
		Для расчета этой метрики также проводим опрос пользователей и вычисляем средний балл. Рассчитывая такой показатель на регулярной основе, можно следить за трендом удовлетворенности пользователей.<br />

		3. Вовлеченность стейкхолдеров<br />
		Количество инициатив и предложений по улучшению процесса и продукта, поступивших в течение итерации (релиза) со стороны стейкхолдеров.<br />
		Назначение метрики: определить степень участия внешних стейкхолдеров (бизнес, инфраструктура, пользователи, поддержка и т.д.) в работе над продуктом. Имея на руках такую метрику, можно сориентироваться, где требуется получить обратную связь, чтобы однажды не столкнуться с проблемами и непониманием.<br /><br />
3.С какой тест. документацией работали?<br />
4.Что такое тест-план?<br />
		-Это документ, который описывает весь объем работ по тестированию, начиная с описания объекта тестирования, стратегии, расписания, критериев начала и окончания тестирования, до необходимого в процессе работы оборудования, специальных знаний, а также оценки рисков с вариантами их разрешения. это документ, который описывает весь объем работ по тестированию, начиная с описания объекта тестирования, стратегии, расписания, критериев начала и окончания тестирования, до необходимого в процессе работы оборудования, специальных знаний, а также оценки рисков с вариантами их разрешения.<br /><br />
5.Что такое тестовая стратегия?<br />
		-Тестовая стратегия определяет то, как мы тестируем продукт. Это набор мыслей и идей, которые направляют процесс тестирования.<br /><br />
6.Что такое чек-лист?<br />
		-Чек-лист – это документ, содержащий ряд необходимых проверок во время тестирования программного продукта.<br /><br />
7.Что такое тест-кейс? Зачем они нужны?<br />
		-Это артефакт, описывающий совокупность шагов, конкретных условий и параметров, необходимых для проверки реализации тестируемой функции или её части.<br /><br />
8.Что такое use case?<br />
		-Описывает сценарий взаимодействия участников (как правило — пользователя и системы). Участников может быть 2 и больше. Пользователем может выступать как человек, так и другая система<br /><br />
9.Что такое тест-сьют?<br />
		-Это набор тест кейсов, которые объединены тем что относятся к одному тестируемому модулю, функциональности, приоритету или одному типу тестирования. Каждый тест сьют состоит из более чем одного тест кейса и зачастую выполняется всей «пачкой» в процессе тестирования.<br /><br />
10.Что такое тест-дизайн?<br />
		-Это этап процесса тестирования ПО, на котором проектируются и создаются тестовые случаи (тест кейсы), в соответствии с определёнными ранее критериями качества и целями тестирования.<br /><br />
11.Что такое позитивный/негативный тест?<br />
		-Позитивный тест кейс использует только корректные данные и проверяет, что приложение правильно выполнило вызываемую функцию.<br />
		-Негативный тест кейс оперирует как корректными так и некорректными данными (минимум 1 некорректный параметр) и ставит целью проверку исключительных ситуаций (срабатывание валидаторов), а также проверяет, что вызываемая приложением функция не выполняется при срабатывании валидатора.<br /><br />
12.Что такое traceability matrix?<br />
		-Это двумерная таблица, содержащая соответствие функциональных требований (functional requirements) продукта и подготовленных тестовых сценариев (test cases). В заголовках колонок таблицы расположены требования, а в заголовках строк — тестовые сценарии. На пересечении — отметка, означающая, что требование текущей колонки покрыто тестовым сценарием текущей строки. Матрица обычно хранится в виде электронной таблицы.<br /><br />

13.Что должно быть в описании бага?<br />
		-Обязательными полями баг репорта являются:<br />
		короткое описание (Bug Summary)<br />
		серьезность (Severity)<br />
		шаги к воспроизведению (Steps to reproduce)<br />
		результат (Actual Result)<br />
		ожидаемый результат (Expected Result)<br /><br />

14.Какой жизненный цикл бага?<br />
		-Это последовательность этапов, которые проходит дефект на своём пути с момента его создания до окончательного закрытия. Для простоты восприятия изображается в виде схемы с возможными статусами и действиями, которые приводят к смене этих статусов.<br /><br />
			новый<br />
		   назначен<br />
			открыт - дублкат отклонен, отсрочен, не баг<br />
			исправлено <br />
		повторное тестирование в режиме ожидания <br />
		повторное тестирование - переоткрыт (возвращается в стадию назначения)<br />
		проверен<br />
		закрыт<br /><br />

15.Что такое тестовое покрытие?<br />
		-это одна из метрик оценки качества тестирования, представляющая из себя плотность покрытия тестами требований либо исполняемого кода<br /><br />

16.В чем разница между приоритетом и важностью ошибки?<br />
		Серьезность (Severity) - это атрибут, характеризующий влияние дефекта на работоспособность приложения.<br />
		Приоритет (Priority) - это атрибут, указывающий на очередность выполнения задачи или устранения дефекта. Можно сказать, что это инструмент менеджера по планированию работ. Чем выше приоритет, тем быстрее нужно исправить дефект.<br /><br />

17.В каких случаях имеет смысл автоматизировать тестирование?<br />
		-Для того чтобы принять решение о целесообразности автоматизации приложения нужно ответить на вопрос «перевешивают ли в нашем случае преимущества?» - хотя бы для некоторой функциональности нашего приложения. Если вы не можете найти таких частей, либо недостатки в вашем случае неприемлемы – от автоматизации стоит воздержаться.<br />
		Преимущества автоматизации тестирования:<br />
		Повторяемость – все написанные тесты всегда будут выполняться однообразно, то есть исключен «человеческий фактор». Тестировщик не пропустит тест по неосторожности и ничего не напутает в результатах.<br />
		Быстрое выполнение – автоматизированному скрипту не нужно сверяться с инструкциями и документациями, это сильно экономит время выполнения.<br />
		Меньшие затраты на поддержку – когда автоматические скрипты уже написаны, на их поддержку и анализ результатов требуется, как правило, меньшее время чем на проведение того же объема тестирования вручную.<br />
		Отчеты – автоматически рассылаемые и сохраняемые отчеты о результатах тестирования.<br />
		Выполнение без вмешательства – во время выполнения тестов инженер-тестировщик может заниматься другими полезными делами, или тесты могут выполняться в нерабочее время (этот метод предпочтительнее, так как нагрузка на локальные сети ночью снижена).<br />
		Недостатки автоматизации тестирования (их тоже немало):<br />
		Повторяемость – все написанные тесты всегда будут выполняться однообразно. Это одновременно является и недостатком, так как тестировщик, выполняя тест вручную, может обратить внимание на некоторые детали и, проведя несколько дополнительных операций, найти дефект. Скрипт этого сделать не может.<br />
		Затраты на поддержку – несмотря на то, что в случае автоматизированных тестов они меньше, чем затраты на ручное тестирование того же функционала – они все же есть. Чем чаще изменяется приложение, тем они выше.<br />
		Большие затраты на разработку – разработка автоматизированных тестов это сложный процесс, так как фактически идет разработка приложения, которое тестирует другое приложение. В сложных автоматизированных тестах также есть фреймворки, утилиты, библиотеки и прочее. Естественно, все это нужно тестировать и отлаживать, а это требует времени.<br />
		Стоимость инструмента для автоматизации – в случае если используется лицензионное ПО, его стоимость может быть достаточно высока. Свободно распространяемые инструменты как правило отличаются более скромным функционалом и меньшим удобством работы.<br />
		Пропуск мелких ошибок - автоматический скрипт может пропускать мелкие ошибки на проверку которых он не запрограммирован. Это могут быть неточности в позиционировании окон, ошибки в надписях, которые не проверяются, ошибки контролов и форм с которыми не осуществляется взаимодействие во время выполнения скрипта.<br /><br />

18.Эквивалентное разбиение<br />
		-это метод тестирования «черного ящика». Идея тестирования по методу разбиения классов эквивалентности состоит в том, чтобы исключить набор входных данных, которые заставляют систему вести себя одинаково и давать одинаковый результат при тестировании программы.<br /><br />

19.BVA – boundary values analysis – анализ граничных значений<br />
		-Это техника проверки поведения продукта на крайних (граничных) значениях входных данных.<br /><br />

20.Черный/белый ящик<br />
		Black Box<br />
		Summary: Мы не знаем, как устроена тестируемая система.<br />
		Тестирование методом «черного ящика», также известное как тестирование, основанное на спецификации или тестирование поведения – техника тестирования, основанная на работе исключительно с внешними интерфейсами тестируемой системы.<br />
		White Box<br />
		Summary: Нам известны все детали реализации тестируемой программы.<br />
		Тестирование методом белого ящика (также: прозрачного, открытого, стеклянного ящика; основанное на коде или структурное тестирование) – метод тестирования программного обеспечения, который предполагает, что внутренняя структура/устройство/реализация системы известны тестировщику. Мы выбираем входные значения, основываясь на знании кода, который будет их обрабатывать. Точно так же мы знаем, каким должен быть результат этой обработки. Знание всех особенностей тестируемой программы и ее реализации – обязательны для этой техники. Тестирование белого ящика – углубление во внутренне устройство системы, за пределы ее внешних интерфейсов.<br /><br />

21.Виды тестирования<br />
		-функциональное<br />
		-системное тестирование<br />
		-тестирование производительности<br />
		-регрессионное тестирование<br />
		-модульное тестирование<br />
		-тестирование безопасности<br />
		-тестирование локализации<br />
		-юзабилити тестирование<br /><br />

22.Статическое и динамическое тестирование<br />
		Статическое тестирование - это тип тестирования, который предполагает, что программный код во время тестирования не будет выполняться. При этом само тестирование может быть как ручным, так и автоматизированным <br />
		Динамическое тестирование – тип тестирования, который предполагает запуск программного кода. <br />
		Таким образом, анализируется поведение программы во время ее работы<br />
		Для выполнения динамического тестирования необходимо чтобы тестируемый программный код был написан,скомпилирован и запущен. При этом, может выполняться проверка внешних параметров работы программы: загрузка процессора, использование памяти, время отклика и т.д. – то есть, ее производительность.<br />
		Динамическое тестирование является частью процесса валидации программного обеспечения.<br />
		Кроме того динамическое тестирование может включать разные подвиды, каждый из которых зависит от:<br />
		• Доступа к коду (тестирование черным, белым и серым ящиками).<br />
		• Уровня тестирования (модульное интеграционное, системное, и  приемочное тестирование).<br />
		• Сферы использования приложения (функциональное, нагрузочное, тестирование безопасности и пр.)<br /><br />

23.Что такое регрессионное тестирование? Какие тесты включаются в регр. набор?<br />
		Регрессионное тестирование – это набор тестов, направленных на обнаружение дефектов в уже протестированных участках приложения.<br />
		Есть несколько видов регрессионных тестов:<br />
		• Верификационные тесты. Проводиться для проверки исправления обнаруженного и открытого ранее бага.<br />
		• Тестирование верификации версии. Содержит принципы дымного тестирования и тестирование сборки: проверка работоспособности основной функциональности программы в каждой новой сборке.<br />
		• Непосредственно само регрессионное тестирование – повторное выполнение всех тестов, которые были написаны и проведены ранее. Они выполняются по уже существующим тест-кейсам независимо от того, были в ходе их прохождения найдены баги, или нет.<br />
		• Тестирование в новом билде уже исправленных багов в старых билдах. Это выполняется для того, чтобы проверить, не возобновило ли обновление билда старых дефектов.<br />
		Некоторые положения относительно того, как проводить регрессионное тестирование:<br />
		• Данный вид тестирования проводится в каждом новом билде.<br />
		• Начинать нужно с верификации версии (тестирование сборки и дымное тестирование).<br />
		• Проверка исправленных багов.<br />
		• Регрессионное тестирование, в основном, не покрывает все приложение, а только те участки, которые тем или иным способом «соприкасаются» с изменениями в билде.<br />
		Далее тестируются уже закрытые ранее баги.<br />
		1) Регрессионное тестирование рекомендуется проводить несколько раз (3-5). Поэтому, с целью экономии драгоценного времени (и, может быть, для избавления от «рутинности») в регрессионных тестах активно используют мощь автоматизации тестирования.<br />
		2) Проведение финального регрессионного тестирования, для которого отбираются тесты по приоритету, определяемому наибольшим количеством найденных ошибок.<br />
		Также регрессионное тестирование активно используется в экстремальной разработке.<br /><br />

24.Что такое smoke test? (heartbeat)<br />
		Дымовое тестирование рассматривается как короткий цикл тестов, выполняемый для подтверждения того, что после сборки кода (нового или исправленного) устанавливаемое приложение, стартует и выполняет основные функции.<br /><br />

25.Что такое end-to-end testing?<br />
		Это тестирование, при котором программный продукт тестируется полность и от начала до конца. На примере пэинта, можно сказать что E2E тестирование будет выглядеть как открытие программы, выбор кисти в программе, выбор цвета кисти, выбор формы кисти, нанесение мазка на холст кистью, сохранение рисунка и выход из приложения<br /><br />

26.Что такое ad-hoc & (exploratory - исследовательское) тестирование?<br />
		Свободное тестирование (ad-hoc testing) – это вид тестирования, который выполняется без подготовки к тестированию продукта, без определения ожидаемых результатов, проектирования тестовых сценариев<br />
		Виды свободного тестирования (ad-hoc testing):<br />
		Buddy testing – процесс, когда 2 человека, как правило разработчик и тестировщик, работают параллельно и находят дефекты в одном и том же модуле тестируемого продукта. Такой вид тестирования помогает тестировщику выполнять необходимые проверки, а разработчику исправлять множество дефектов на ранних этапах.<br />
		Pair testing – процесс, когда 2 тестировщика проверяют один модуль и помогают друг другу. К примеру, один может искать дефекты, а второй их документировать. Таким образом, у одного тестера будет функция, скажем так, обнаружителя, у другого – описателя.<br />
		Monkey testing – произвольное тестирование продукта с целью как можно быстрее, используя различные вариации входных данных, нарушить работу программы или вызвать ее остановку (простыми словами – сломать).<br />
		Исследовательское тестирование (exploratory testing) — это одновременное изучение программного продукта, проектирование тестов и их выполнение.<br /><br />

27.Что такое acceptance testing?<br />
		Формальный процесс тестирования, который проверяет соответствие системы требованиям и проводится с целью:<br />
		определения удовлетворяет ли система приемочным критериям;<br />
		вынесения решения заказчиком или другим уполномоченным лицом принимается приложение или нет.<br /><br />

28.CMM, TMM, RUP<br />
		CMM (Capability Maturity Model) "модель зрелости возможностей". Подразумевает модель зрелости процессов в компании.<br />
		Уровень 1 - начальный (initial). Хаотический процесс, который характеризуется, как правило, полным отсутствием документации и быстрыми изменениями продукта. Считается, что результат такого процесса непредсказуем;<br />
		Уровень 2 - воспроизводимый (repeatable). Характеристика процесса, который частично воспроизводим и дает предсказуемый результат. Процессы, как правило не сильно формализованы, но достаточны для тех продуктов, которые разрабатывает компания;<br />
		Уровень 3 - определенный (defined). Процесс характеризуется формализацией и планом улучшения процесса с течением времени;<br />
		Уровень 4 - управляемый (managed). Процесс формализован и контролируется с помощью набора метрик, позволяющих измерить эффективность процесса. На основании статистики по этим метрикам можно прогнозировать результаты будущих разработок;<br />
		Уровень 5 - улучшеный (optimized). Процесс постоянно улучшается путем применения технических и административных инноваций;<br />
		Testability Maturity Model (TMM) базируется на CMM<br />
		RUP (Rational Unified Process) – методология разработки ПО, созданная компанией Rational Software<br />
		Основные принципы:<br />
		1 — ранняя идентификация и непрерывное (до окончания проекта) устранение основных рисков<br />
		2 — концентрация на выполнении требований заказчиков к исполняемой программе<br />
		3 — ожидание изменений в требованиях, проектных решениях и реализации в процессе разработки<br />
		4 — компонентная архитектура, реализуемая и тестируемая на ранних стадиях проекта<br />
		5 — постоянное обеспечение качества на всех этапах разработки проекта (продукта)<br />
		6 — работа над проектом в сплочённой команде, ключевая роль в которой принадлежит архитекторам<br /><br />

29.Общие сценарии нагрузочного/стресс тестирования, тестирования производительности<br />
		
30.В чем различия тестирования веб- и десктоп приложений?<br />
31.QA and QC <br />
32.Тестирование чашки/ручки/лифта/калькулятора<br />
33.Какое соотношение между кол-вом тестировщиков и программистов оптимально?<br />
34.Что такое Scrum/Agile методологии?<br />
35.Что такое жизненный цикл разработки ПО? Типичные проблемы<br />
36.Что такое жизненный цикл тестирования?<br />
37.Что вы делаете, когда нету требований/спецификаций?<br />
38.Что вы делаете, когда требования меняются?<br />
39.Когда можно закончить тестирование?<br />
40.Что вы делаете, когда выясняется, что в нужный срок не вы не сможете выполнить все запланированные тесты?<br />
41.Как вы взаимодействуете с другими членами команды?<br />
42.Опишите наиболее интересный (или просто последний) баг, который вы обнаружили<br />
43.Как работать с командной строкой?<br />
44.Как работает компьютер?<br />
45.Как работает процессор?<br />
46.Что такое регистр?<br />
47.Как работает память?<br />
48.Что такое cookies и как с ними работать? <br />
49.Как работает кеширование? <br />
50.Как работает поток? <br />
51.Как работает буфер? <br />
52.Как работает сервер, клиент? <br />
53.Как работает протокол? <br />
54.Как работает файловая система?  <br />
55.Что такое логин?  <br />
	</p>
<h1><p align="center">Технологии</p></h1>
	<p>
1.Html <br />
2.http – различие post and get queries <br />
3.отслеживание и модификация http quries <br />
4.Xml, xpath <br />
5.Вирт. машины <br />
6.SQL запросы <br />
7.Что такое cookies, cache<br />
8.Как можно вызвать событие submit формы через адресную строку?<br />
	</p>
	</html>